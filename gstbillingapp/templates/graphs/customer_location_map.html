{% extends "base.html" %}
{% load static %}

{% block content %}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
<link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css"/>

<style>
    /* Remove container padding and make full width */
    body { margin: 0; padding: 0; overflow: hidden; }
    .container { padding: 0 !important; max-width: 100% !important; width: 100% !important; margin: 0 !important; }
    
    /* Full screen layout */
    .map-wrapper { 
        position: fixed; 
        top: 0;
        left: 0; 
        right: 0; 
        bottom: 0; 
        display: flex; 
        background: #1a1a1a;
        z-index: 1;
    }
    
    /* Map takes full remaining space */
    #map { 
        flex: 1; 
        height: 100%; 
        z-index: 1;
    }
    
    /* Side panel - collapsible */
    .side-panel { 
        width: 380px; 
        min-width: 380px;
        height: 100%; 
        background: white; 
        box-shadow: -2px 0 8px rgba(0,0,0,0.15);
        display: flex; 
        flex-direction: column;
        overflow: hidden;
        z-index: 10;
        transition: all 0.3s ease;
        transform: translateX(0);
    }
    
    .side-panel.collapsed {
        min-width: 0;
        width: 0;
        transform: translateX(380px);
    }
    
    /* Toggle button for panel */
    .panel-toggle {
        position: fixed;
        right: 390px;
        top: 10px;
        background: white;
        border: 1px solid #ddd;
        border-right: none;
        border-radius: 4px 0 0 4px;
        padding: 10px 8px;
        cursor: pointer;
        z-index: 1001;
        box-shadow: -2px 2px 6px rgba(0,0,0,0.1);
        transition: right 0.3s ease;
    }
    
    .panel-toggle.panel-collapsed {
        right: 10px;
    }
    
    /* Header section */
    .panel-header {
        padding: 16px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .panel-header h2 {
        margin: 0;
        font-size: 20px;
        font-weight: 600;
    }
    
    /* Toolbar section */
    .toolbar { 
        padding: 12px 16px;
        display: flex; 
        flex-wrap: wrap; 
        gap: 8px;
        background: #fafafa;
        border-bottom: 1px solid #e0e0e0;
    }
    
    .btn { 
        padding: 8px 12px; 
        border: 1px solid #ddd; 
        border-radius: 4px; 
        background: white; 
        cursor: pointer;
        font-size: 13px;
        font-weight: 500;
        transition: all 0.2s;
        flex: 1;
        min-width: 90px;
    }
    
    .btn:hover:not(:disabled) { 
        background: #f0f0f0; 
        border-color: #999;
        transform: translateY(-1px);
    }
    
    .btn:active:not(:disabled) {
        transform: translateY(0);
    }
    
    .btn:disabled { 
        opacity: 0.5; 
        cursor: not-allowed; 
    }
    
    .btn-primary {
        background: #667eea;
        color: white;
        border-color: #667eea;
    }
    
    .btn-primary:hover:not(:disabled) {
        background: #5568d3;
        border-color: #5568d3;
    }
    
    /* Search section */
    .search-section {
        padding: 12px 16px;
        background: white;
    }
    
    .field { 
        width: 100%; 
        padding: 10px 12px; 
        border: 2px solid #e0e0e0; 
        border-radius: 6px;
        font-size: 14px;
        transition: border-color 0.2s;
    }
    
    .field:focus {
        outline: none;
        border-color: #667eea;
    }
    
    /* Customer list */
    .list-section {
        flex: 1;
        overflow-y: auto;
        background: white;
    }
    
    #customer-list { 
        list-style: none; 
        padding: 0; 
        margin: 0;
    }
    
    #customer-list li { 
        padding: 12px 16px; 
        border-bottom: 1px solid #f0f0f0; 
        cursor: pointer;
        transition: background 0.2s;
        font-size: 14px;
    }
    
    #customer-list li:hover { 
        background: #f8f9ff; 
    }
    
    #customer-list li.active { 
        background: #e3f2fd; 
        border-left: 3px solid #667eea;
        font-weight: 500;
    }
    
    /* Routing card */
    .routing-card { 
        border-top: 2px solid #e0e0e0; 
        padding: 16px;
        background: #fafafa;
    }
    
    .routing-card label {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 12px;
        font-weight: 500;
        font-size: 14px;
    }
    
    .routing-actions {
        display: flex;
        gap: 8px;
        margin-bottom: 12px;
    }
    
    #distance-summary { 
        padding: 12px;
        background: white;
        border-radius: 6px;
        font-size: 13px;
        color: #333;
        line-height: 1.6;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        margin-bottom: 8px;
        max-height: 200px;
        overflow-y: auto;
    }
    
    .status { 
        font-size: 12px; 
        font-weight: 500;
        padding: 8px;
        border-radius: 4px;
        background: white;
    }
    
    /* Checkbox styling */
    input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
    }
    
    /* Leaflet controls positioning */
    .leaflet-control-container { 
        z-index: 1000; 
    }
    
    .leaflet-control-layers {
        margin-right: 10px !important;
    }
    
    /* Scrollbar styling */
    .list-section::-webkit-scrollbar,
    #distance-summary::-webkit-scrollbar {
        width: 8px;
    }
    
    .list-section::-webkit-scrollbar-track,
    #distance-summary::-webkit-scrollbar-track {
        background: #f1f1f1;
    }
    
    .list-section::-webkit-scrollbar-thumb,
    #distance-summary::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 4px;
    }
    
    .list-section::-webkit-scrollbar-thumb:hover,
    #distance-summary::-webkit-scrollbar-thumb:hover {
        background: #555;
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
        .side-panel {
            width: 100%;
            max-width: 320px;
        }
        
        .panel-toggle {
            right: calc(100% - 320px + 10px);
        }
        
        .panel-toggle.panel-collapsed {
            right: 10px;
        }
        
        .side-panel.collapsed {
            transform: translateX(100%);
        }
        
        .btn {
            min-width: 70px;
            padding: 6px 8px;
            font-size: 12px;
        }
    }
</style>

<!-- Panel Toggle Button -->
<button class="panel-toggle" id="panel-toggle" title="Toggle Panel">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="15 18 9 12 15 6"></polyline>
    </svg>
</button>

<div class="map-wrapper">
    <div id="map"
         data-user-lat="{{ user.business_latitude|default_if_none:'' }}"
         data-user-lng="{{ user.business_longitude|default_if_none:'' }}"></div>

    <div class="side-panel" id="side-panel">
        <div class="panel-header">
            <h2>Customer Locations</h2>
        </div>
        
        <div class="toolbar">
            <button id="reset-view" class="btn" title="Reset map view">Reset View</button>
            <button id="locate-me" class="btn" title="Find my location">Locate Me</button>
            <button onclick="window.history.back()" class="btn" title="Go back">Go Back</button>
        </div>
        
        <div class="search-section">
            <input id="search" type="text" placeholder="ðŸ” Search customers..." class="field">
            <label style="display:flex; align-items:center; gap:8px; margin-top:10px; font-size:13px;">
                <input id="show-labels" type="checkbox"> Show marker labels on map
            </label>
        </div>

        <div class="list-section">
            <ul id="customer-list">
        {% for c in customers %}
            <li data-lat="{{ c.customer_latitude }}" data-lng="{{ c.customer_longitude }}">
                {{ c }}
            </li>
            {% empty %}
            <li>No customer locations available.</li>
            {% endfor %}
            </ul>
        </div>

        <div class="routing-card">
            <label>
                <input id="routing-mode" type="checkbox"> Routing Mode
            </label>
            <div class="routing-actions">
                <button id="start-at-user" type="button" class="btn btn-primary">Start at My Location</button>
                <button id="clear-route" type="button" class="btn">Clear Route</button>
            </div>
            <div id="distance-summary"></div>
            <div id="routing-status" class="status"></div>
        </div>
    </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
<script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>

<script>
    // Base layers
    const osmStreets = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19, attribution: '&copy; OpenStreetMap contributors', zIndex: 1
    });
    const esriSat = L.tileLayer(
        'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
        { maxZoom: 19, attribution: 'Tiles &copy; Esri', zIndex: 1 }
    );
    const esriLabels = L.tileLayer(
        'https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}',
        { maxZoom: 19, attribution: 'Labels &copy; Esri', zIndex: 2 }
    );

    const circlesGroup = L.layerGroup();
    const baseLayers = { 'Street (OSM)': osmStreets, 'Satellite (Esri)': esriSat };
    const circles5kmGroup = L.layerGroup();
    const overlays = { 'Labels (Esri)': esriLabels, '1 km circles': circlesGroup, '5 km circles': circles5kmGroup };

    const defaultCenter = [20.5937, 78.9629];
    const map = L.map('map', { center: defaultCenter, zoom: 5, layers: [esriSat, esriLabels] });
    L.control.layers(baseLayers, overlays, { position: 'topright', collapsed: false }).addTo(map);
    L.control.scale({ metric: true, imperial: false }).addTo(map);

    map.on('baselayerchange', (e) => {
        if (e.layer === esriSat) esriLabels.addTo(map);
        else map.removeLayer(esriLabels);
    });

    // DOM refs
    const list = document.getElementById('customer-list');
    const search = document.getElementById('search');
    const resetViewBtn = document.getElementById('reset-view');
    const locateBtn = document.getElementById('locate-me');
    const showLabelsChk = document.getElementById('show-labels');
    const startAtUserBtn = document.getElementById('start-at-user');

    const customers = Array.from(list.querySelectorAll('li[data-lat][data-lng]'))
        .map(li => ({
            el: li,
            lat: parseFloat(li.dataset.lat),
            lng: parseFloat(li.dataset.lng),
            label: li.textContent.trim()
        }))
        .filter(c => Number.isFinite(c.lat) && Number.isFinite(c.lng));

    // Markers
    const markersByLatLng = new Map();
    const bounds = [];
    const markers = [];

    let labelsEnabled = !!JSON.parse(localStorage.getItem('labelsEnabled') || 'false');
    showLabelsChk.checked = labelsEnabled;

    function applyTooltip(marker, label) {
        if (marker.getTooltip()) marker.unbindTooltip();
        if (labelsEnabled && label) {
            marker.bindTooltip(label, { permanent: true, direction: 'top', offset: [0, -10] });
        }
    }

    customers.forEach((cust) => {
        const marker = L.marker([cust.lat, cust.lng]).addTo(map).bindPopup(cust.label || '');
        
        // Bind tooltip that shows on hover
        marker.bindTooltip(cust.label, { 
            permanent: false,  // Show only on hover
            direction: 'top', 
            offset: [0, -10],
            className: 'hover-tooltip'
        });
        
        // Apply permanent labels if enabled
        if (labelsEnabled) {
            marker.bindTooltip(cust.label, { permanent: true, direction: 'top', offset: [0, -10] });
        }
        
        markers.push({ marker, label: cust.label });
        const key = `${cust.lat},${cust.lng}`;
        markersByLatLng.set(key, marker);
        bounds.push([cust.lat, cust.lng]);

        // Allow adding stops by clicking markers on the map
        marker.on('click', () => {
            if (routingMode) {
                addWaypointWithStart(cust.lat, cust.lng, cust.label);
            } else {
                marker.openPopup();
            }
        });

        L.circle([cust.lat, cust.lng], {
            radius: 1000, color: '#1976d2', weight: 1, opacity: 0.3,
            fillColor: '#2196f3', fillOpacity: 0.15, interactive: false
        }).addTo(circlesGroup);
        L.circle([cust.lat, cust.lng], {
            radius: 5000, color: '#1976d2', weight: 1, opacity: 0.3,
            fillColor: '#2196f3', fillOpacity: 0.15, interactive: false
        }).addTo(circles5kmGroup);
    });

    // Headquarters (from user.business_latitude/longitude)
    const mapEl = document.getElementById('map');
    let hqLat = parseFloat(mapEl.dataset.userLat);
    let hqLng = parseFloat(mapEl.dataset.userLng);
    let hqMarker = null;
    const hqLabel = 'Headquarters';

    const redIcon = L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
        iconRetinaUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
        shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
        iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34],
        tooltipAnchor: [16, -28], shadowSize: [41, 41]
    });

    function addOrUpdateHQ(lat, lng) {
        hqLat = lat; hqLng = lng;
        if (hqMarker) hqMarker.remove();
        hqMarker = L.marker([lat, lng], { icon: redIcon }).addTo(map).bindPopup(hqLabel);
        applyTooltip(hqMarker, hqLabel);
        markers.push({ marker: hqMarker, label: hqLabel });
        markersByLatLng.set(`${lat},${lng}`, hqMarker);
        bounds.push([lat, lng]);

        L.circle([lat, lng], {
            radius: 1000, color: '#d32f2f', weight: 1, opacity: 0.3,
            fillColor: '#f44336', fillOpacity: 0.15, interactive: false
        }).addTo(circlesGroup);
        L.circle([lat, lng], {
            radius: 5000, color: '#d32f2f', weight: 1, opacity: 0.3,
            fillColor: '#f44336', fillOpacity: 0.15, interactive: false
        }).addTo(circles5kmGroup);
    }

    if (Number.isFinite(hqLat) && Number.isFinite(hqLng)) addOrUpdateHQ(hqLat, hqLng);

    if (bounds.length) map.fitBounds(bounds, { padding: [20, 20] });

    // Current device location (via "Locate me") â€“ does NOT change HQ
    let currentLat = null, currentLng = null, currentMarker = null;
    const greenIcon = L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png',
        iconRetinaUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
        shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
        iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34],
        tooltipAnchor: [16, -28], shadowSize: [41, 41]
    });
    const currentLabel = 'My Location';

    function addOrUpdateCurrent(lat, lng) {
        currentLat = lat; currentLng = lng;
        if (currentMarker) currentMarker.remove();
        currentMarker = L.marker([lat, lng], { icon: greenIcon }).addTo(map).bindPopup(currentLabel);
        applyTooltip(currentMarker, currentLabel);
        markers.push({ marker: currentMarker, label: currentLabel });
        markersByLatLng.set(`${lat},${lng}`, currentMarker);
        bounds.push([lat, lng]);

        L.circle([lat, lng], {
            radius: 1000, color: '#2e7d32', weight: 1, opacity: 0.3,
            fillColor: '#4caf50', fillOpacity: 0.15, interactive: false
        }).addTo(circlesGroup);
        L.circle([lat, lng], {
            radius: 5000, color: '#2e7d32', weight: 1, opacity: 0.3,
            fillColor: '#4caf50', fillOpacity: 0.15, interactive: false
        }).addTo(circles5kmGroup);
    }

    // List interactions
    list.addEventListener('click', (e) => {
        const li = e.target.closest('li[data-lat][data-lng]');
        if (!li) return;
        Array.from(list.children).forEach(el => el.classList.remove('active'));
        li.classList.add('active');

        const lat = parseFloat(li.dataset.lat);
        const lng = parseFloat(li.dataset.lng);
        if (!Number.isFinite(lat) || !Number.isFinite(lng)) return;

        if (routingMode) {
            addWaypointWithStart(lat, lng, li.textContent.trim());
        } else {
            const marker = markersByLatLng.get(`${lat},${lng}`);
            map.setView([lat, lng], Math.max(map.getZoom(), 13));
            if (marker) marker.openPopup();
        }
    });

    // Search
    search.addEventListener('input', () => {
        const q = search.value.toLowerCase();
        customers.forEach(c => {
            const match = c.label.toLowerCase().includes(q);
            c.el.style.display = match ? '' : 'none';
        });
    });

    // Labels toggle
    showLabelsChk.addEventListener('change', () => {
        labelsEnabled = showLabelsChk.checked;
        localStorage.setItem('labelsEnabled', JSON.stringify(labelsEnabled));
        markers.forEach(({ marker, label }) => applyTooltip(marker, label));
    });

    // Reset view
    resetViewBtn.addEventListener('click', () => {
        if (bounds.length) map.fitBounds(bounds, { padding: [20, 20] });
    });

    // Geolocate (does NOT modify HQ)
    locateBtn.addEventListener('click', () => {
        if (!navigator.geolocation) {
            alert('Geolocation not supported.');
            return;
        }
        locateBtn.disabled = true;
        locateBtn.textContent = 'Locating...';
        navigator.geolocation.getCurrentPosition(
            (pos) => {
                addOrUpdateCurrent(pos.coords.latitude, pos.coords.longitude);
                map.setView([pos.coords.latitude, pos.coords.longitude], 14);
                locateBtn.disabled = false;
                locateBtn.textContent = 'Locate me';
                
                // If routing mode is active, offer to use current location as start
                if (routingMode && waypoints.length === 0) {
                    routingStatus.textContent = 'Current location detected! Click customers to build route.';
                    routingStatus.style.color = '#2e7d32';
                }
            },
            () => { 
                alert('Unable to fetch location. Please enable location services.'); 
                locateBtn.disabled = false;
                locateBtn.textContent = 'Locate me';
            },
            { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
        );
    });

    // Routing
    const routingToggle = document.getElementById('routing-mode');
    const clearBtn = document.getElementById('clear-route');
    const distanceSummary = document.getElementById('distance-summary');
    const routingStatus = document.getElementById('routing-status');

    let routingMode = false;
    let waypoints = [];
    let routingControl = null;

    // Initialize routing control immediately
    function initRoutingControl() {
        if (routingControl) return;
        
        routingControl = L.Routing.control({
            waypoints: [],
            show: false,
            routeWhileDragging: false,
            addWaypoints: false,
            router: L.Routing.osrmv1({
                serviceUrl: 'https://router.project-osrm.org/route/v1',
                profile: 'driving',
                timeout: 15000
            }),
            lineOptions: {
                styles: [{ color: '#0288d1', weight: 6, opacity: 0.85 }],
                addWaypoints: false
            },
            createMarker: function(i, wp) {
                const markerIcon = i === 0 ? greenIcon : (i === waypoints.length - 1 && waypoints.length > 1 ? redIcon : L.icon({
                    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png',
                    iconRetinaUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
                    shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
                    iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34],
                    tooltipAnchor: [16, -28], shadowSize: [41, 41]
                }));
                return L.marker(wp.latLng, { icon: markerIcon }).bindTooltip(`Stop ${i + 1}`, { permanent: true, direction: 'top', offset: [0, -10] });
            }
        }).addTo(map);

        routingControl.on('routesfound', (e) => {
            const route = e.routes[0];
            const totalKm = (route.summary.totalDistance / 1000).toFixed(2);
            const totalMin = Math.round(route.summary.totalTime / 60);
            const stopsCount = waypoints.length;
            
            // Build detailed leg-by-leg breakdown
            let legDetails = '<strong>Route Details:</strong><br>';
            legDetails += `<strong>Total:</strong> ${stopsCount} stops, ${totalKm} km, ${totalMin} min<br><br>`;
            
            // Show individual legs with accurate distances
            if (route.instructions && waypoints.length > 1) {
                legDetails += '<strong>Segments:</strong><br>';
                
                // Calculate distance for each leg by finding waypoint transitions in instructions
                let currentWaypointIndex = 0;
                let legDistance = 0;
                let legTime = 0;
                let legNumber = 1;
                
                for (let i = 0; i < route.instructions.length; i++) {
                    const instr = route.instructions[i];
                    legDistance += instr.distance || 0;
                    legTime += instr.time || 0;
                    
                    // Check if we've reached the next waypoint
                    const isLastInstruction = i === route.instructions.length - 1;
                    const nextInstrIsWaypoint = !isLastInstruction && route.instructions[i + 1].type === 'WaypointReached';
                    
                    if (nextInstrIsWaypoint || isLastInstruction) {
                        if (currentWaypointIndex < waypoints.length - 1) {
                            const fromLabel = waypoints[currentWaypointIndex].label || `Stop ${currentWaypointIndex + 1}`;
                            const toLabel = waypoints[currentWaypointIndex + 1].label || `Stop ${currentWaypointIndex + 2}`;
                            
                            const legKm = (legDistance / 1000).toFixed(2);
                            const legMin = Math.round(legTime / 60);
                            
                            legDetails += `${legNumber}. ${fromLabel} â†’ ${toLabel}: <strong>${legKm} km</strong>, ${legMin} min<br>`;
                            
                            legNumber++;
                            currentWaypointIndex++;
                            legDistance = 0;
                            legTime = 0;
                        }
                        
                        // Skip the WaypointReached instruction
                        if (nextInstrIsWaypoint) i++;
                    }
                }
                
                // Fallback: if instruction-based calculation didn't work, divide total by legs
                if (legNumber === 1 && waypoints.length > 1) {
                    for (let i = 0; i < waypoints.length - 1; i++) {
                        const fromLabel = waypoints[i].label || `Stop ${i + 1}`;
                        const toLabel = waypoints[i + 1].label || `Stop ${i + 2}`;
                        
                        const legKm = (route.summary.totalDistance / (waypoints.length - 1) / 1000).toFixed(2);
                        const legMin = Math.round(route.summary.totalTime / (waypoints.length - 1) / 60);
                        
                        legDetails += `${i + 1}. ${fromLabel} â†’ ${toLabel}: <strong>${legKm} km</strong>, ${legMin} min (estimated)<br>`;
                    }
                }
            }
            
            distanceSummary.innerHTML = legDetails;
            routingStatus.textContent = `Route calculated successfully with ${stopsCount} stops!`;
            routingStatus.style.color = '#2e7d32';
        });

        routingControl.on('routingerror', (e) => {
            console.error('Routing error:', e);
            routingStatus.textContent = 'Routing service error. Try different points or check internet connection.';
            routingStatus.style.color = '#d32f2f';
        });

        console.log('Routing control initialized');
    }

    // Initialize on page load
    initRoutingControl();

    function addStartIfNeeded() {
        if (waypoints.length === 0) {
            if (Number.isFinite(currentLat) && Number.isFinite(currentLng)) {
                waypoints.push({ lat: currentLat, lng: currentLng, label: currentLabel });
                routingStatus.textContent = `Starting from ${currentLabel}. Click customers to add stops.`;
                routingStatus.style.color = '#1976d2';
                return true;
            } else if (Number.isFinite(hqLat) && Number.isFinite(hqLng)) {
                waypoints.push({ lat: hqLat, lng: hqLng, label: hqLabel });
                routingStatus.textContent = `Starting from ${hqLabel}. Click customers to add stops.`;
                routingStatus.style.color = '#1976d2';
                return true;
            } else {
                routingStatus.textContent = 'No start point. Click "Locate me" or set Headquarters first.';
                routingStatus.style.color = '#d32f2f';
                return false;
            }
        }
        return true;
    }

    function updateRoute() {
        if (!routingControl) {
            console.error('Routing control not initialized');
            return;
        }

        // Remove exact duplicates
        const uniq = [];
        waypoints.forEach(w => {
            if (!uniq.some(u => Math.abs(u.lat - w.lat) < 1e-7 && Math.abs(u.lng - w.lng) < 1e-7)) {
                uniq.push(w);
            }
        });
        waypoints = uniq;

        console.log('Updating route with waypoints:', waypoints.length);
        
        // Set waypoints
        const latLngs = waypoints.map(w => L.latLng(w.lat, w.lng));
        routingControl.setWaypoints(latLngs);
        
        if (waypoints.length >= 2) {
            routingStatus.textContent = 'Calculating route...';
            routingStatus.style.color = '#1976d2';
            // Force route calculation
            setTimeout(() => {
                if (routingControl && routingControl.route) {
                    routingControl.route();
                }
            }, 100);
        } else if (waypoints.length === 1) {
            distanceSummary.innerHTML = `<strong>Route Summary:</strong><br>1 stop added. Add more to calculate route.`;
            routingStatus.textContent = 'Add at least one more stop to calculate route.';
            routingStatus.style.color = '#f57c00';
        } else {
            distanceSummary.innerHTML = '';
            routingStatus.textContent = '';
        }
    }

    function addWaypoint(lat, lng, label) {
        // Check for duplicates
        if (waypoints.some(w => Math.abs(w.lat - lat) < 1e-7 && Math.abs(w.lng - lng) < 1e-7)) {
            routingStatus.textContent = `${label} is already in the route!`;
            routingStatus.style.color = '#f57c00';
            return;
        }
        
        waypoints.push({ lat, lng, label });
        console.log(`Added waypoint: ${label} (${lat}, ${lng})`);
        
        if (waypoints.length === 1) {
            routingStatus.textContent = `Starting point set to ${label}. Add more stops to calculate route.`;
            routingStatus.style.color = '#1976d2';
        } else {
            routingStatus.textContent = `Added ${label} to route (${waypoints.length} stops)`;
            routingStatus.style.color = '#2e7d32';
        }
        updateRoute();
    }

    function addWaypointWithStart(lat, lng, label) {
        // Simply add the waypoint - no forced start point
        addWaypoint(lat, lng, label);
    }

    routingToggle.addEventListener('change', () => {
        routingMode = routingToggle.checked;
        if (routingMode) {
            console.log('Routing mode enabled');
            routingStatus.textContent = 'Routing mode enabled. Click any customer/location to start, then add more stops.';
            routingStatus.style.color = '#1976d2';
        } else {
            console.log('Routing mode disabled');
            waypoints = [];
            distanceSummary.innerHTML = '';
            routingStatus.textContent = 'Routing mode disabled.';
            routingStatus.style.color = '#666';
            if (routingControl) {
                routingControl.setWaypoints([]);
            }
            Array.from(list.children).forEach(el => el.classList.remove('active'));
        }
    });

    // "Start at My Location" prefers device location; falls back to Headquarters
    startAtUserBtn.disabled = false;
    startAtUserBtn.addEventListener('click', () => {
        routingMode = true;
        routingToggle.checked = true;
        waypoints = [];

        const startFromCurrent = Number.isFinite(currentLat) && Number.isFinite(currentLng);
        const startFromHQ = Number.isFinite(hqLat) && Number.isFinite(hqLng);

        if (startFromCurrent) {
            waypoints = [{ lat: currentLat, lng: currentLng, label: currentLabel }];
            routingStatus.textContent = 'âœ“ Start set to My Location. Click customers to add stops.';
            routingStatus.style.color = '#2e7d32';
            map.setView([currentLat, currentLng], 14);
            updateRoute();
        } else if (startFromHQ) {
            waypoints = [{ lat: hqLat, lng: hqLng, label: hqLabel }];
            routingStatus.textContent = 'âœ“ Start set to Headquarters. Click customers to add stops.';
            routingStatus.style.color = '#2e7d32';
            map.setView([hqLat, hqLng], 14);
            updateRoute();
        } else if (navigator.geolocation) {
            routingStatus.textContent = 'ðŸ“ Detecting your current location...';
            routingStatus.style.color = '#1976d2';
            startAtUserBtn.disabled = true;
            startAtUserBtn.textContent = 'Locating...';
            
            navigator.geolocation.getCurrentPosition(
                (pos) => {
                    addOrUpdateCurrent(pos.coords.latitude, pos.coords.longitude);
                    waypoints = [{ lat: currentLat, lng: currentLng, label: currentLabel }];
                    map.setView([currentLat, currentLng], 14);
                    updateRoute();
                    routingStatus.textContent = 'âœ“ Start set to My Location. Click customers to add stops.';
                    routingStatus.style.color = '#2e7d32';
                    startAtUserBtn.disabled = false;
                    startAtUserBtn.textContent = 'Start at My Location';
                },
                (error) => {
                    console.error('Geolocation error:', error);
                    if (startFromHQ) {
                        waypoints = [{ lat: hqLat, lng: hqLng, label: hqLabel }];
                        routingStatus.textContent = 'âš  Location unavailable. Using Headquarters as start.';
                        routingStatus.style.color = '#f57c00';
                        updateRoute();
                    } else {
                        routingStatus.textContent = 'âœ— Unable to fetch location. Click "Locate me" first or set Headquarters.';
                        routingStatus.style.color = '#d32f2f';
                    }
                    startAtUserBtn.disabled = false;
                    startAtUserBtn.textContent = 'Start at My Location';
                },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
        } else {
            routingStatus.textContent = 'âœ— Geolocation not available. Click "Locate me" or set Headquarters.';
            routingStatus.style.color = '#d32f2f';
        }
    });

    clearBtn.addEventListener('click', () => {
        console.log('Clearing route');
        waypoints = [];
        distanceSummary.innerHTML = '';
        routingStatus.textContent = 'Route cleared. Click any customer/location to start a new route.';
        routingStatus.style.color = '#1976d2';
        if (routingControl) {
            // Remove all waypoints and routing display
            routingControl.setWaypoints([]);
            // Force remove the route by triggering an empty route
            if (routingControl._line) {
                map.removeLayer(routingControl._line);
            }
            // Remove route markers
            if (routingControl._markers) {
                routingControl._markers.forEach(marker => {
                    if (marker) map.removeLayer(marker);
                });
            }
        }
        Array.from(list.children).forEach(el => el.classList.remove('active'));
    });

    // Log current state for debugging
    console.log('Customer Location Map initialized');
    console.log('Headquarters:', Number.isFinite(hqLat) && Number.isFinite(hqLng) ? `${hqLat}, ${hqLng}` : 'Not set');
    console.log('Total customers with coordinates:', customers.length);
    
    // Panel toggle functionality
    const panelToggle = document.getElementById('panel-toggle');
    const sidePanel = document.getElementById('side-panel');
    let panelCollapsed = false;
    
    panelToggle.addEventListener('click', () => {
        panelCollapsed = !panelCollapsed;
        if (panelCollapsed) {
            sidePanel.classList.add('collapsed');
            panelToggle.classList.add('panel-collapsed');
            panelToggle.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"></polyline></svg>';
            panelToggle.title = 'Show Panel';
        } else {
            sidePanel.classList.remove('collapsed');
            panelToggle.classList.remove('panel-collapsed');
            panelToggle.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 18 9 12 15 6"></polyline></svg>';
            panelToggle.title = 'Hide Panel';
        }
        
        // Force immediate resize during transition
        requestAnimationFrame(() => {
            map.invalidateSize(true);
        });
        
        // Final resize after animation completes
        setTimeout(() => {
            map.invalidateSize(true);
        }, 350);
    });
    
    // Invalidate size on window resize
    window.addEventListener('resize', () => {
        map.invalidateSize(true);
    });
    
    // Initial map size fix - multiple attempts for reliability
    setTimeout(() => {
        map.invalidateSize(true);
    }, 100);
    
    setTimeout(() => {
        map.invalidateSize(true);
        if (bounds.length) {
            map.fitBounds(bounds, { padding: [20, 20] });
        }
    }, 500);

</script>
{% endblock %}